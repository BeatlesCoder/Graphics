// The implementation is based on the demo on "fine pruned tiled lighting" published in GPU Pro 7.
// https://github.com/wolfgangfengel/GPU-Pro-7

#pragma kernel ScreenBoundsAABB                   SCRAABBGEN=ScreenBoundsAABB
#pragma kernel ScreenBoundsAABB_Oblique           SCRAABBGEN=ScreenBoundsAABB_Oblique           USE_OBLIQUE_MODE


#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition-config/Runtime/ShaderConfig.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightCullUtils.hlsl"

// #pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 playstation xboxone vulkan metal switch

uniform int g_isOrthographic;
uniform int g_iNrVisibLights;

uniform float4x4 g_mInvProjectionArr[SHADEROPTIONS_XR_MAX_VIEWS];
uniform float4x4 g_mProjectionArr[SHADEROPTIONS_XR_MAX_VIEWS];

StructuredBuffer<SFiniteLightBound> g_data : register( t0 );

#define NR_THREADS          64

// output buffer
RWStructuredBuffer<float4> g_vBoundsBuffer : register( u0 );

#define Z_BINNING
#define DUMB_COMPILER
// #define USE_WAVE_INTRINSICS // We use TGSM and atomic operations if wave intrinsics are not supported

#ifdef Z_BINNING

// Returns the location of the N-th set bit starting from the lowest order bit and working upward.
// Slow implementation - do not use for large bit sets.
// Could be optimized - see https://graphics.stanford.edu/~seander/bithacks.html
uint NthBitLow(uint value, uint n)
{
    uint b = -1;                                    // Consistent with the behavior of firstbitlow()
    uint c = countbits(value);

    if (n < c)                                      // Validate inputs
    {
        uint r = n + 1;                             // Compute the number of remaining bits

        do
        {
            uint f = firstbitlow(value >> (b + 1)); // Find the next set bit
            b += f + r;                             // Make a guess (assume all [b+f+1,b+f+r] bits are set)
            c = countbits(value << (32 - (b + 1))); // Count the number of bits actually set
            r = (n + 1) - c;                        // Compute the number of remaining bits
        } while (r > 0);
    }

    return b;
}

float4x4 Translation4x4(float3 d)
{
    float4x4 M = k_Identity4x4;

    M._14_24_34 = d; // Last column

    return M;
}

float3x3 Rotation3x3(float3 xAxis, float3 yAxis, float3 zAxis)
{
    float3x3 R = float3x3(xAxis, yAxis, zAxis);
    float3x3 C = transpose(R); // Row to column

    return C;
}

float3x3 Invert3x3(float3x3 R)
{
    float3x3 C   = transpose(R); // Row to column
    float    det = dot(C[0], cross(C[1], C[2]));
    float3x3 adj = float3x3(cross(C[1], C[2]),
                            cross(C[2], C[0]),
                            cross(C[0], C[1]));
    return rcp(det) * adj;
}

float4x4 Homogenize3x3(float3x3 R)
{
    float4x4 M = float4x4(float4(R[0], 0),
                          float4(R[1], 0),
                          float4(R[2], 0),
                          float4(0,0,0,1));
    return M;
}

float4x4 PerspectiveProjection4x4(float a, float g, float n, float f)
{
    float b = (f + n) * rcp(f - n);    // z: [-1, 1]
    float c = -2 * f * n * rcp(f - n); // No Z-reversal

    return float4x4(g/a, 0, 0, 0,
                      0, g, 0, 0,
                      0, 0, b, c,
                      0, 0, 1, 0);
}

#define CLEAR_SIGN_BIT(X)  (asuint(X) & INT_MAX)
#define DIV_ROUND_UP(N, D) (((N) + (D) - 1) / (D)) // No division by 0 checks

// Clipping a plane by a cube may produce a hexagon (6-gon).
// Clipping a hexagon by 4 planes may produce a decagon (10-gon).
#define MAX_CLIP_VERTS    (10)
#define NUM_VERTS         (8)
#define NUM_FACES         (6)
#define NUM_PLANES        (6)
#define THREADS_PER_GROUP (64)
#define THREADS_PER_LIGHT (4) // Set to 1 for debugging
#define LIGHTS_PER_GROUP  (THREADS_PER_GROUP / THREADS_PER_LIGHT)
#define VERTS_PER_GROUP   (NUM_VERTS * LIGHTS_PER_GROUP)
#define VERTS_PER_THREAD  (NUM_VERTS / THREADS_PER_LIGHT)
#define FACES_PER_THREAD  DIV_ROUND_UP(NUM_FACES, THREADS_PER_LIGHT)

// All planes and faces are always in the standard order (see below).
// Near and far planes are swapped in the case of Z-reversal, but it does not affect the algorithm.
#define FACE_LEFT   (1 << 0) // x = -1
#define FACE_RIGHT  (1 << 1) // x = +1
#define FACE_FRONT  (1 << 2) // y = -1
#define FACE_BACK   (1 << 3) // y = +1
#define FACE_TOP    (1 << 4) // z = -1
#define FACE_BOTTOM (1 << 5) // z = +1
#define FACE_MASK   ((1 << NUM_FACES) - 1)

// TODO: the compiler generates 'tbuffer_load_format_x' instructions
// when we access the look-up tables. Can we avoid this?

// TODO: try vert order (0 0 0), (1 0 0), (0 1 0), (1 1 0), (0 0 1), (1 0 1), (0 1 1), (1 1 1)

// All vertices are always in the standard order (see below).
static const uint s_FaceMasksOfVerts[NUM_VERTS] =
{
    FACE_LEFT  | FACE_FRONT | FACE_TOP,    // 0: (-1, -1, -1)
    FACE_RIGHT | FACE_FRONT | FACE_TOP,    // 1: (+1, -1, -1)
    FACE_RIGHT | FACE_BACK  | FACE_TOP,    // 2: (+1, +1, -1)
    FACE_LEFT  | FACE_BACK  | FACE_TOP,    // 3: (-1, +1, -1)
    FACE_LEFT  | FACE_FRONT | FACE_BOTTOM, // 4: (-1, -1, +1)
    FACE_RIGHT | FACE_FRONT | FACE_BOTTOM, // 5: (+1, -1, +1)
    FACE_RIGHT | FACE_BACK  | FACE_BOTTOM, // 6: (+1, +1, +1)
    FACE_LEFT  | FACE_BACK  | FACE_BOTTOM  // 7: (-1, +1, +1)
};

// CCW order (starting with the LSB) of vertices for each face (w.r.t. its normal),
// with normals pointing in the interior of the volume.
static const uint s_VertMasksOfFaces[NUM_FACES] =
{
    (3) << 9 | (7) << 6 | (4) << 3 | (0) << 0, // 0: FACE_LEFT
    (5) << 9 | (6) << 6 | (2) << 3 | (1) << 0, // 1: FACE_RIGHT
    (4) << 9 | (5) << 6 | (1) << 3 | (0) << 0, // 2: FACE_FRONT
    (6) << 9 | (7) << 6 | (3) << 3 | (2) << 0, // 3: FACE_BACK
    (1) << 9 | (2) << 6 | (3) << 3 | (0) << 0, // 4: FACE_TOP
    (7) << 9 | (6) << 6 | (5) << 3 | (4) << 0  // 5: FACE_BOTTOM
};

// 5 arrays * 128 elements * 4 bytes each = 2560 bytes.
groupshared float gs_HapVertsX[VERTS_PER_GROUP];
groupshared float gs_HapVertsY[VERTS_PER_GROUP];
groupshared float gs_HapVertsZ[VERTS_PER_GROUP];
groupshared float gs_HapVertsW[VERTS_PER_GROUP];
groupshared uint  gs_BehindMasksOfVerts[VERTS_PER_GROUP]; // 6 planes each (HLSL does not support small data types)

#ifndef USE_WAVE_INTRINSICS
// 1 array *  16 elements * 4 bytes each = 64 bytes.
groupshared uint  gs_CullClipFaceMasks[LIGHTS_PER_GROUP]; // 6 faces  each (HLSL does not support small data types)

// 8 arrays * 16 elements * 4 bytes each = 512 bytes.
// These are actually floats reinterpreted as uints.
// The reason is because floating-point atomic operations are not supported.
groupshared uint  gs_RapAaBbMinPtX[LIGHTS_PER_GROUP];
groupshared uint  gs_RapAaBbMaxPtX[LIGHTS_PER_GROUP];
groupshared uint  gs_RapAaBbMinPtY[LIGHTS_PER_GROUP];
groupshared uint  gs_RapAaBbMaxPtY[LIGHTS_PER_GROUP];
groupshared uint  gs_RapAaBbMinPtZ[LIGHTS_PER_GROUP]; // The W component is only stored to maintain
groupshared uint  gs_RapAaBbMaxPtZ[LIGHTS_PER_GROUP]; // compatibility with the legacy clustered
groupshared uint  gs_RapAaBbMinPtW[LIGHTS_PER_GROUP]; // lighting system. Reconstructing min-W from
groupshared uint  gs_RapAaBbMaxPtW[LIGHTS_PER_GROUP]; // min-Z is non-trivial for oblique projections.
#endif // USE_WAVE_INTRINSICS

// Returns 'true' if it manages to cull the face.
bool TryCullFace(uint f, uint behindMasksOfVerts[NUM_VERTS])
{
    uint cullMaskOfFace = FACE_MASK; // Initially behind
    uint vertMaskOfFace = s_VertMasksOfFaces[f];

    for (int j = 0; j < 4; j++)
    {
        uint v = BitFieldExtract(vertMaskOfFace, 3 * j, 3);
        // Non-zero if ALL the vertices are behind any of the planes.
        cullMaskOfFace &= behindMasksOfVerts[v];
    }

    return (cullMaskOfFace != 0);
}

struct ClipVertex
{
    float4 pt; // Homogeneous coordinate after perspective
    float  bc; // Boundary coordinate with respect to the plane 'p'
};

ClipVertex CreateClipVertex(uint p, float4 v)
{
    bool evenPlane = (p % 2) == 0;

    float c = v[p / 2];
    float w = v.w;

    ClipVertex cv;

    cv.pt = v;
    cv.bc = evenPlane ? c : w - c; // dot(PlaneEquation, HapVertex);

    return cv;
}

float4 IntersectEdgeAgainstPlane(ClipVertex v0, ClipVertex v1)
{
    float alpha = saturate(v0.bc * rcp(v0.bc - v1.bc)); // Guaranteed to lie between 0 and 1

    return lerp(v0.pt, v1.pt, alpha);
}

void ClipPolygonAgainstPlane(uint p, uint srcBegin, uint srcSize,
                             inout float4 vertRingBuffer[MAX_CLIP_VERTS],
                             out uint dstBegin, out uint dstSize)
{
    dstBegin = srcBegin + srcSize; // Start at the end; we don't use modular arithmetic here
    dstSize  = 0;

    ClipVertex tailVert = CreateClipVertex(p, vertRingBuffer[(srcBegin + srcSize - 1) % MAX_CLIP_VERTS]);

#ifdef DUMB_COMPILER
    uint modSrcIdx = srcBegin % MAX_CLIP_VERTS;
    uint modDstIdx = dstBegin % MAX_CLIP_VERTS;
#endif

    for (uint k = srcBegin; k < (srcBegin + srcSize); k++)
    {
    #ifndef DUMB_COMPILER
        uint modSrcIdx = k % MAX_CLIP_VERTS;
    #endif
        ClipVertex leadVert = CreateClipVertex(p, vertRingBuffer[modSrcIdx]);

        // Execute Blinn's line clipping algorithm.
        // Classify the line segment. 4 cases:
        // 0. v0 out, v1 out -> add nothing
        // 1. v0 in,  v1 out -> add intersection
        // 2. v0 out, v1 in  -> add intersection, add v1
        // 3. v0 in,  v1 in  -> add v1
        // (bc >= 0) <-> in, (bc < 0) <-> out. Beware of the signed zero.

        if ((tailVert.bc >= 0) != (leadVert.bc >= 0))
        {
            // The line segment is guaranteed to cross the plane.
            float4 clipVert = IntersectEdgeAgainstPlane(tailVert, leadVert);
        #ifndef DUMB_COMPILER
            uint modDstIdx = (dstBegin + dstSize++) % MAX_CLIP_VERTS;
        #endif
            vertRingBuffer[modDstIdx] = clipVert;
        #ifdef DUMB_COMPILER
            dstSize++;
            modDstIdx++;
            modDstIdx = (modDstIdx == MAX_CLIP_VERTS) ? 0 : modDstIdx;
        #endif
        }

        if (leadVert.bc >= 0)
        {
        #ifndef DUMB_COMPILER
            uint modDstIdx = (dstBegin + dstSize++) % MAX_CLIP_VERTS;
        #endif
            vertRingBuffer[modDstIdx] = leadVert.pt;
        #ifdef DUMB_COMPILER
            dstSize++;
            modDstIdx++;
            modDstIdx = (modDstIdx == MAX_CLIP_VERTS) ? 0 : modDstIdx;
        #endif
        }

    #ifdef DUMB_COMPILER
        modSrcIdx++;
        modSrcIdx = (modSrcIdx == MAX_CLIP_VERTS) ? 0 : modSrcIdx;
    #endif
        tailVert = leadVert; // Avoid recomputation and overwriting the vertex in the ring buffer
    }
}

void ClipFaceAgainstViewVolumeAndUpdateAaBb(uint f, uint behindMasksOfVerts[NUM_VERTS], uint firstVertexOffset, float4x4 g_mInvProjection,
                                            inout float4 rapAaBbMinPt, inout float4 rapAaBbMaxPt)
{
    float4 vertRingBuffer[MAX_CLIP_VERTS];
    uint srcBegin = 0, srcSize = 4;

    uint clipMaskOfFace = 0; // Initially in front
    uint vertMaskOfFace = s_VertMasksOfFaces[f];

    for (int j = 0; j < 4; j++)
    {
        uint v = BitFieldExtract(vertMaskOfFace, 3 * j, 3);
        // Non-zero if ANY of the vertices are behind any of the planes.
        clipMaskOfFace |= behindMasksOfVerts[v];

        // Not all edges may require clipping. However, filtering the vertex list
        // is somewhat expensive, so we currently don't do it.
        vertRingBuffer[j].x = gs_HapVertsX[firstVertexOffset + v];
        vertRingBuffer[j].y = gs_HapVertsY[firstVertexOffset + v];
        vertRingBuffer[j].z = gs_HapVertsZ[firstVertexOffset + v];
        vertRingBuffer[j].w = gs_HapVertsW[firstVertexOffset + v];
    }

    const uint numPlanesToClipAgainst = countbits(clipMaskOfFace); // [1, 6]

    // Sutherland-Hodgeman polygon clipping algorithm.
    // It works by clipping the entire polygon against one clipping plane at a time.
    for (uint j = 0; j < numPlanesToClipAgainst; j++)
    {
        uint p = firstbitlow(clipMaskOfFace);

        uint dstBegin, dstSize;
        ClipPolygonAgainstPlane(p, srcBegin, srcSize, vertRingBuffer, dstBegin, dstSize);

        srcBegin = dstBegin;
        srcSize  = dstSize;

        clipMaskOfFace ^= 1 << p; // Clear the bit to continue using firstbitlow()
    }

#ifdef DUMB_COMPILER
    uint modSrcIdx = srcBegin % MAX_CLIP_VERTS;
#endif

    for (uint j = srcBegin; j < (srcBegin + srcSize); j++)
    {
    #ifndef DUMB_COMPILER
        uint modSrcIdx = j % MAX_CLIP_VERTS;
    #endif

        float4 hapVert    = vertRingBuffer[modSrcIdx];
        float4 hbpVertVS  = mul(g_mInvProjection, hapVert);         // Just to support orthographic projection
        float3 rapVertNDC = saturate(hapVert.xyz * rcp(hapVert.w)); // Must not generate negative values
        float  rbpVertVSz = hbpVertVS.z * rcp(hbpVertVS.w);

        rapAaBbMinPt.xyz  = min(rapAaBbMinPt.xyz, rapVertNDC);
        rapAaBbMaxPt.xyz  = max(rapAaBbMaxPt.xyz, rapVertNDC);
        rapAaBbMinPt.w    = min(rapAaBbMinPt.w,   rbpVertVSz);
        rapAaBbMaxPt.w    = max(rapAaBbMaxPt.w,   rbpVertVSz);

    #ifdef DUMB_COMPILER
        modSrcIdx++;
        modSrcIdx = (modSrcIdx == MAX_CLIP_VERTS) ? 0 : modSrcIdx;
    #endif
    }
}

#else // !Z_BINNING

#define THREADS_PER_LIGHT (8)
#define THREADS_PER_GROUP (64)
#define LIGHTS_PER_GROUP  (THREADS_PER_GROUP / THREADS_PER_LIGHT)
#define MAX_PNTS          (9)   // strictly this should be 10=6+4 but we get more wavefronts and 10 seems to never hit (fingers crossed)
                                // However, worst case the plane that would be skipped if such an extreme case ever happened would be backplane
                                // clipping gets skipped which doesn't cause any errors.


// LDS (2496 bytes)
groupshared float posX[MAX_PNTS*8*2];
groupshared float posY[MAX_PNTS*8*2];
groupshared float posZ[MAX_PNTS*8*2];
groupshared float posW[MAX_PNTS*8*2];
groupshared unsigned int clipFlags[48];


unsigned int GetClip(const float4 P);
int ClipAgainstPlane(const int iSrcIndex, const int iNrSrcVerts, const int subLigt, const int p);
void CalcBound(out bool2 bIsMinValid, out bool2 bIsMaxValid, out float2 vMin, out float2 vMax, float4x4 InvProjection, float3 pos_view_space, float r);

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightingConvexHullUtils.hlsl"

#endif // Z_BINNING

[numthreads(NR_THREADS, 1, 1)]
void SCRAABBGEN(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID)
{
    uint groupID = u3GroupID.x;
    uint eyeIndex = u3GroupID.y; // currently, can only be 0 or 1

    // The g_ is preserved in order to make cross-pipeline (FPTL) updates easier
    float4x4 g_mInvProjection = g_mInvProjectionArr[eyeIndex];
    float4x4 g_mProjection = g_mProjectionArr[eyeIndex];

    //uint vindex = groupID * NR_THREADS + threadID;
    unsigned int g = groupID;
    unsigned int t = threadID;

    const int subLigt = (uint) (t/THREADS_PER_LIGHT);
    const int lgtIndex = subLigt+(uint) g*LIGHTS_PER_GROUP;
    const int sideIndex = (uint) (t%8);

    const int eyeAdjustedLgtIndex = GenerateLightCullDataIndex(lgtIndex, g_iNrVisibLights, eyeIndex);
    SFiniteLightBound lgtDat = g_data[eyeAdjustedLgtIndex];

#ifdef Z_BINNING
    //**********************************************************************************************
    // The goal of this program is to compute the AABB of the light in the NDC space ([0, 1] range).
    // The light is represented by a convex volume (a cuboid) with 6 faces (planar quads) and 8 vertices.
    //
    // Since a light volume may be partially off-screen, we must clip it before computing the AABB.
    // Clipping the resulting AABB (rather than the light volume itself) may result in a loose AABB.
    //
    // To avoid having to deal with the "Moebius twist" property of the perspective transform,
    // we perform clipping using the homogeneous (projective) post-perspective coordinates.
    // This clipping method in described in Blinn's paper titled "Line Clipping".
    //
    // The algorithm processes a light on 4 threads. While all 6 faces may require clipping in the
    // worst case, clipping more than 4 faces is very uncommon (typically, we clip 0, 3 or 4).
    // Some faces may require culling rather than clipping (the former is simpler).
    //
    // It's important to realize that face culling may end up culling 5 (or even all 6) faces.
    // This means that the clipped light volume may be reduced to a single polygon, or nothing at all.
    // (Imagine a view volume completely or partially inside a light volume).
    // Therefore, we must perform view-volume-corner-inside-light-volume tests.
    //
    //
    // Notation:
    // rbp - real (3D) coordinates before perspective
    // hbp - hom. (4D) coordinates before perspective
    // hap - hom. (4D) coordinates after  perspective
    // rap - real (3D) coordinates after  perspective (after division by w)
    // *********************************************************************************************

    const uint groupLocalLightIndex = t / THREADS_PER_LIGHT;
    const uint firstVertexOffset    = NUM_VERTS * groupLocalLightIndex;

    const float  scale = lgtDat.scaleXY;      // scale.x = scale.y
    const float3 rbpC  = lgtDat.center.xyz;
    // TODO: store X, Y, Scale
    const float3 rbpX  = lgtDat.boxAxisX.xyz; // Pre-scaled
    const float3 rbpY  = lgtDat.boxAxisY.xyz; // Pre-scaled
    const float3 rbpZ  = lgtDat.boxAxisZ.xyz; // Pre-scaled

#ifndef USE_WAVE_INTRINSICS
    // (0) Initialize the TGSM.
    if (t % THREADS_PER_LIGHT == 0) // Avoid bank conflicts
    {
        gs_CullClipFaceMasks[groupLocalLightIndex] = 0; // Initially inside
        gs_RapAaBbMinPtX[groupLocalLightIndex]     = asuint(1.0f);
        gs_RapAaBbMaxPtX[groupLocalLightIndex]     = asuint(0.0f);
        gs_RapAaBbMinPtY[groupLocalLightIndex]     = asuint(1.0f);
        gs_RapAaBbMaxPtY[groupLocalLightIndex]     = asuint(0.0f);
        gs_RapAaBbMinPtZ[groupLocalLightIndex]     = asuint(1.0f);
        gs_RapAaBbMaxPtZ[groupLocalLightIndex]     = asuint(0.0f);
        gs_RapAaBbMinPtW[groupLocalLightIndex]     = asuint(FLT_INF);
        gs_RapAaBbMaxPtW[groupLocalLightIndex]     = asuint(0.0f);
    }
#endif // USE_WAVE_INTRINSICS

    float4 rapAaBbMinPt = float4(1, 1, 1, FLT_INF);
    float4 rapAaBbMaxPt = 0;

    // We must determine whether we have to clip or cull any of the faces.
    // If all vertices of a face are inside with respect to all the culling planes,
    // we can trivially accept that face. If all vertices of a face are behind
    // any single plane, we can trivially reject (cull) that face.
    uint cullClipFaceMask = 0; // Initially inside

    // (1) Compute the vertices of the light volume.
    for (uint i = 0; i < VERTS_PER_THREAD; i++)
    {
        uint v = i * THREADS_PER_LIGHT + t % THREADS_PER_LIGHT;

        // rbpVerts[0] = rbpC - rbpX * scale.x - rbpY * scale.y - rbpZ; // (-1, -1, -1)
        // rbpVerts[1] = rbpC + rbpX * scale.x - rbpY * scale.y - rbpZ; // (+1, -1, -1)
        // rbpVerts[2] = rbpC + rbpX * scale.x + rbpY * scale.y - rbpZ; // (+1, +1, -1)
        // rbpVerts[3] = rbpC - rbpX * scale.x + rbpY * scale.y - rbpZ; // (-1, +1, -1)
        // rbpVerts[4] = rbpC - rbpX           - rbpY           + rbpZ; // (-1, -1, +1)
        // rbpVerts[5] = rbpC + rbpX           - rbpY           + rbpZ; // (+1, -1, +1)
        // rbpVerts[6] = rbpC + rbpX           + rbpY           + rbpZ; // (+1, +1, +1)
        // rbpVerts[7] = rbpC - rbpX           + rbpY           + rbpZ; // (-1, +1, +1)

        float3 m; // See the comment above

        m.x = (countbits(v % 4) == 1) ? 1 : -1;
        m.y = ((v & 2) != 0)          ? 1 : -1;
        m.z = (v >= 4)                ? 1 : -1;

        m.xy *= (v >= 4) ? 1 : scale;

        float3 rbpVertVS = rbpC + m.x * rbpX + m.y * rbpY + m.z * rbpZ;
        // Avoid generating (w = 0).
        rbpVertVS.z = (abs(rbpVertVS.z) > FLT_MIN) ? rbpVertVS.z : FLT_MIN;

        float4 hapVert = mul(g_mProjection, float4(rbpVertVS, 1));

        // Warning: the W component may be negative.
        // Flipping the -W pyramid by negating all coordinates is incorrect
        // and will break both classification and clipping.

        // Transform the X and Y components: [-w, w] -> [0, w].
        hapVert.xy = 0.5 * hapVert.xy + (0.5 * hapVert.w);

        // TODO: multiply vertex by ViewZ if orthographic for unified processing!

        // For each vertex, we must determine whether it is within the bounds.
        // For culling and clipping, we must know, per culling plane, whether the vertex
        // is in the positive or the negative half-space.
        uint behindMask = 0; // Initially in front

        // Consider the vertex to be inside the view volume if:
        // 0 <= x <= w
        // 0 <= y <= w   <-- include boundary points to avoid clipping them later
        // 0 <= z <= w
        // w is always valid
        // For the orthographic projection, (w = 1), so no modifications are necessary.
        // TODO: epsilon for numerical robustness?

        for (uint j = 0; j < (NUM_PLANES / 2); j++)
        {
            float w = hapVert.w;

            behindMask |= (hapVert[j] < 0 ? 1 : 0) << (2 * j + 0); // Planes crossing '0'
            behindMask |= (hapVert[j] > w ? 1 : 0) << (2 * j + 1); // Planes crossing 'w'
        }

        if (behindMask == 0) // Inside?
        {
            float3 rapVertNDC = saturate(hapVert.xyz * rcp(hapVert.w)); // Must not generate negative values

            rapAaBbMinPt.xyz = min(rapAaBbMinPt.xyz, rapVertNDC);
            rapAaBbMaxPt.xyz = max(rapAaBbMaxPt.xyz, rapVertNDC);
            rapAaBbMinPt.w   = min(rapAaBbMinPt.w,   rbpVertVS.z);
            rapAaBbMaxPt.w   = max(rapAaBbMaxPt.w,   rbpVertVS.z);
        }
        else // Outside
        {
            cullClipFaceMask |= s_FaceMasksOfVerts[v];
        }

        gs_HapVertsX[firstVertexOffset + v]          = hapVert.x;
        gs_HapVertsY[firstVertexOffset + v]          = hapVert.y;
        gs_HapVertsZ[firstVertexOffset + v]          = hapVert.z;
        gs_HapVertsW[firstVertexOffset + v]          = hapVert.w;
        gs_BehindMasksOfVerts[firstVertexOffset + v] = behindMask;
    }

#ifdef USE_WAVE_INTRINSICS
    // ...
#else
    InterlockedOr(gs_CullClipFaceMasks[groupLocalLightIndex], cullClipFaceMask);

    GroupMemoryBarrierWithGroupSync();

    cullClipFaceMask = gs_CullClipFaceMasks[groupLocalLightIndex];
#endif

    // (2) Test the corners of the view volume.
    if (cullClipFaceMask != 0)
    {
        // The light is partially outside the view volume.
        // Therefore, some of the corners of the view volume may be inside the light volume.
        // We perform aggressive culling, so we must make sure they are accounted for.
        // The light volume is a special type of cuboid - a right frustum.
        // We can exploit this fact by building a light-space projection matrix.
        float4x4 invTranslateToLightSpace      = Translation4x4(-rbpC);
        float4x4 invRotateAndScaleInLightSpace = Homogenize3x3(Invert3x3(Rotation3x3(rbpX, rbpY, rbpZ)));
        // TODO: avoid full inversion by using unit vectors and passing magnitudes explicitly.

        // This (orthographic) projection matrix maps a view-space point to a light-space [-1, 1]^3 cube.
        float4x4 lightSpaceMatrix = mul(invRotateAndScaleInLightSpace, invTranslateToLightSpace);

        if (scale != 1) // Perspective light space?
        {
            // Compute the parameters of the perspective projection.
            float s = scale;
            float e = -1 - 2 * (s * rcp(1 - s)); // Signed distance from the origin to the eye
            float n = -e - 1;                    // Distance from the eye to the near plane
            float f = -e + 1;                    // Distance from the eye to the far plane
            float g = f;                         // Distance from the eye to the projection plane

            float4x4 invTranslateEye = Translation4x4(float3(0, 0, -e));
            float4x4 perspProjMatrix = PerspectiveProjection4x4(1, g, n, f);

            lightSpaceMatrix = mul(mul(perspProjMatrix, invTranslateEye), lightSpaceMatrix);
        }

        for (uint i = 0; i < VERTS_PER_THREAD; i++)
        {
            uint v = i * THREADS_PER_LIGHT + t % THREADS_PER_LIGHT;

            // rapVertsCS[0] = (-1, -1, 0)
            // rapVertsCS[1] = (+1, -1, 0)
            // rapVertsCS[2] = (+1, +1, 0)
            // rapVertsCS[3] = (-1, +1, 0)
            // rapVertsCS[4] = (-1, -1, 1)
            // rapVertsCS[5] = (+1, -1, 1)
            // rapVertsCS[6] = (+1, +1, 1)
            // rapVertsCS[7] = (-1, +1, 1)

            float3 rapVertCS; // See the comment above

            rapVertCS.x = (countbits(v % 4) == 1) ? 1 : -1;
            rapVertCS.y = ((v & 2) != 0)          ? 1 : -1;
            rapVertCS.z = (v >= 4)                ? 1 :  0;

            float4 hbpVertVS = mul(g_mInvProjection, float4(rapVertCS, 1)); // Clip to view space
            float4 hapVertLS = mul(lightSpaceMatrix, hbpVertVS);            // View to light space

            // Consider the vertex to be inside the light volume if:
            // -w < x < w
            // -w < y < w   <-- exclude boundary points, as we will not clip using these vertices
            // -w < z < w   <-- assume that Z-precision is not very important here
            // 0  < w
            // For the orthographic projection, (w = 1), so no modifications are necessary.
            // TODO: epsilon for numerical robustness?

            bool inside = Max3(abs(hapVertLS.x), abs(hapVertLS.y), abs(hapVertLS.z)) < hapVertLS.w;

            if (inside)
            {
                float3 rapVertNDC = float3(rapVertCS.xy * 0.5 + 0.5, rapVertCS.z);
                float  rbpVertVSz = hbpVertVS.z * rcp(hbpVertVS.w);

                rapAaBbMinPt.xyz = min(rapAaBbMinPt.xyz, rapVertNDC);
                rapAaBbMaxPt.xyz = max(rapAaBbMaxPt.xyz, rapVertNDC);
                rapAaBbMinPt.w   = min(rapAaBbMinPt.w,   rbpVertVSz);
                rapAaBbMaxPt.w   = max(rapAaBbMaxPt.w,   rbpVertVSz);
            }
        }
    }

    uint behindMasksOfVerts[NUM_VERTS];

    for (uint i = 0; i < NUM_VERTS; i++)
    {
        behindMasksOfVerts[i] = gs_BehindMasksOfVerts[firstVertexOffset + i];
    }

    // (3) Cull the faces.
    {
        const uint cullFaceMask   = cullClipFaceMask;
        const uint numFacesToCull = countbits(cullFaceMask); // [0, 6]

        for (uint i = 0; i < FACES_PER_THREAD; i++)
        {
            uint n = i * THREADS_PER_LIGHT + t % THREADS_PER_LIGHT;

            if (n < numFacesToCull)
            {
                uint f = NthBitLow(cullFaceMask, n);

                if (TryCullFace(f, behindMasksOfVerts))
                {
                    cullClipFaceMask ^= 1 << f; // Clear the bit
                }
            }
        }
    }

#ifdef USE_WAVE_INTRINSICS
    // ...
#else
    InterlockedAnd(gs_CullClipFaceMasks[groupLocalLightIndex], cullClipFaceMask);

    GroupMemoryBarrierWithGroupSync();

    cullClipFaceMask = gs_CullClipFaceMasks[groupLocalLightIndex];
#endif

    // (4) Clip the faces.
    {
        const uint clipFaceMask   = cullClipFaceMask;
        const uint numFacesToClip = countbits(clipFaceMask); // [0, 6]

        for (uint i = 0; i < FACES_PER_THREAD; i++)
        {
            uint n = i * THREADS_PER_LIGHT + t % THREADS_PER_LIGHT;

            if (n < numFacesToClip)
            {
                uint f = NthBitLow(clipFaceMask, n);

                ClipFaceAgainstViewVolumeAndUpdateAaBb(f, behindMasksOfVerts, firstVertexOffset, g_mInvProjection,
                                                       rapAaBbMinPt, rapAaBbMaxPt);
            }
        }
    }

#ifdef USE_WAVE_INTRINSICS
    // ...
#else
    // Integer comparison works for floating-point numbers as long as the sign bit is 0.
    // We must take care of the signed zero ourselves.
    InterlockedMin(gs_RapAaBbMinPtX[groupLocalLightIndex], asuint(CLEAR_SIGN_BIT(rapAaBbMinPt.x)));
    InterlockedMax(gs_RapAaBbMaxPtX[groupLocalLightIndex], asuint(CLEAR_SIGN_BIT(rapAaBbMaxPt.x)));
    InterlockedMin(gs_RapAaBbMinPtY[groupLocalLightIndex], asuint(CLEAR_SIGN_BIT(rapAaBbMinPt.y)));
    InterlockedMax(gs_RapAaBbMaxPtY[groupLocalLightIndex], asuint(CLEAR_SIGN_BIT(rapAaBbMaxPt.y)));
    InterlockedMin(gs_RapAaBbMinPtZ[groupLocalLightIndex], asuint(CLEAR_SIGN_BIT(rapAaBbMinPt.z)));
    InterlockedMax(gs_RapAaBbMaxPtZ[groupLocalLightIndex], asuint(CLEAR_SIGN_BIT(rapAaBbMaxPt.z)));
    InterlockedMin(gs_RapAaBbMinPtW[groupLocalLightIndex], asuint(CLEAR_SIGN_BIT(rapAaBbMinPt.w)));
    InterlockedMax(gs_RapAaBbMaxPtW[groupLocalLightIndex], asuint(CLEAR_SIGN_BIT(rapAaBbMaxPt.w)));

    GroupMemoryBarrierWithGroupSync();

    rapAaBbMinPt.x = asfloat(gs_RapAaBbMinPtX[groupLocalLightIndex]);
    rapAaBbMaxPt.x = asfloat(gs_RapAaBbMaxPtX[groupLocalLightIndex]);
    rapAaBbMinPt.y = asfloat(gs_RapAaBbMinPtY[groupLocalLightIndex]);
    rapAaBbMaxPt.y = asfloat(gs_RapAaBbMaxPtY[groupLocalLightIndex]);
    rapAaBbMinPt.z = asfloat(gs_RapAaBbMinPtZ[groupLocalLightIndex]);
    rapAaBbMaxPt.z = asfloat(gs_RapAaBbMaxPtZ[groupLocalLightIndex]);
    rapAaBbMinPt.w = asfloat(gs_RapAaBbMinPtW[groupLocalLightIndex]);
    rapAaBbMaxPt.w = asfloat(gs_RapAaBbMaxPtW[groupLocalLightIndex]);
#endif // USE_WAVE_INTRINSICS

    if (t % THREADS_PER_LIGHT == 0) // Avoid bank conflicts
    {
        // Each light's AABB is represented by two float3s, the min and max of the box.
        // And for stereo, we have two sets of lights. Therefore, each eye has a set of mins, followed by
        // a set of maxs, and each set is equal to g_iNrVisibLights.
        const ScreenSpaceBoundsIndices boundsIndices = GenerateScreenSpaceBoundsIndices(lgtIndex, g_iNrVisibLights, eyeIndex);

        g_vBoundsBuffer[boundsIndices.min] = rapAaBbMinPt;
        g_vBoundsBuffer[boundsIndices.max] = rapAaBbMaxPt;
    }

#else // !Z_BINNING
    const float3 boxX = lgtDat.boxAxisX.xyz;
    const float3 boxY = lgtDat.boxAxisY.xyz;
    const float3 boxZ = -lgtDat.boxAxisZ.xyz;           // flip axis (so it points away from the light direction for a spot-light)
    const float3 center = lgtDat.center.xyz;
    const float radius = lgtDat.radius;
    const float2 scaleXY = lgtDat.scaleXY;

    {
        if(sideIndex<6 && lgtIndex<(int) g_iNrVisibLights)      // mask 2 out of 8 threads
        {
            float3 q0, q1, q2, q3;
            GetHullQuad(q0, q1, q2, q3, boxX, boxY, boxZ, center, scaleXY, sideIndex);


            const float4 vP0 = mul(g_mProjection, float4(q0, 1));
            const float4 vP1 = mul(g_mProjection, float4(q1, 1));
            const float4 vP2 = mul(g_mProjection, float4(q2, 1));
            const float4 vP3 = mul(g_mProjection, float4(q3, 1));

            // test vertices of one quad (of the convex hull) for intersection
            const unsigned int uFlag0 = GetClip(vP0);
            const unsigned int uFlag1 = GetClip(vP1);
            const unsigned int uFlag2 = GetClip(vP2);
            const unsigned int uFlag3 = GetClip(vP3);

            const float4 vPnts[] = {vP0, vP1, vP2, vP3};

            // screen-space AABB of one quad (assuming no intersection)
            float3 vMin, vMax;
            for(int k=0; k<4; k++)
            {
                float fW = vPnts[k].w;
                float fS = fW<0 ? -1 : 1;
                float fWabs = fW<0 ? (-fW) : fW;
                fW = fS * (fWabs<FLT_EPS ? FLT_EPS : fWabs);
                float3 vP = float3(vPnts[k].x/fW, vPnts[k].y/fW, vPnts[k].z/fW);
                if(k==0) { vMin=vP; vMax=vP; }

                vMax = max(vMax, vP); vMin = min(vMin, vP);
            }

            clipFlags[subLigt*6+sideIndex] = (uFlag0<<0) | (uFlag1<<6) | (uFlag2<<12) | (uFlag3<<18);

            // store in clip buffer (only use these vMin and vMax if light is 100% visible in which case clipping isn't needed)
            posX[subLigt*MAX_PNTS*2 + sideIndex] = vMin.x;
            posY[subLigt*MAX_PNTS*2 + sideIndex] = vMin.y;
            posZ[subLigt*MAX_PNTS*2 + sideIndex] = vMin.z;

            posX[subLigt*MAX_PNTS*2 + sideIndex + 6] = vMax.x;
            posY[subLigt*MAX_PNTS*2 + sideIndex + 6] = vMax.y;
            posZ[subLigt*MAX_PNTS*2 + sideIndex + 6] = vMax.z;
        }
    }

    // if not XBONE and not PLAYSTATION4 we need a memorybarrier here
    // since we can't rely on the gpu cores being 64 wide.
    // We need a pound define around this.
    GroupMemoryBarrierWithGroupSync();


    {
        int f=0;

        if(sideIndex==0 && lgtIndex<(int) g_iNrVisibLights)
        {
            // quick acceptance or rejection
            unsigned int uCollectiveAnd = (unsigned int) -1;
            unsigned int uCollectiveOr = 0;
            for(f=0; f<6; f++)
            {
                unsigned int uFlagAnd = clipFlags[subLigt*6+f]&0x3f;
                unsigned int uFlagOr = uFlagAnd;
                for(int i=1; i<4; i++)
                {
                    unsigned int uClipBits = (clipFlags[subLigt*6+f]>>(i*6))&0x3f;
                    uFlagAnd &= uClipBits;
                    uFlagOr |= uClipBits;
                }

                uCollectiveAnd &= uFlagAnd;
                uCollectiveOr |= uFlagOr;
            }

            bool bSetBoundYet = false;
            float3 vMin=0.0, vMax=0.0;
            if(uCollectiveAnd!=0 || uCollectiveOr==0)       // all invisible or all visible (early out)
            {
                if(uCollectiveOr==0)    // all visible
                {
                    for(f=0; f<6; f++)
                    {
                        const int sideIndex = f;

                        float3 vFaceMi = float3(posX[subLigt*MAX_PNTS*2 + sideIndex + 0], posY[subLigt*MAX_PNTS*2 + sideIndex + 0], posZ[subLigt*MAX_PNTS*2 + sideIndex + 0]);
                        float3 vFaceMa = float3(posX[subLigt*MAX_PNTS*2 + sideIndex + 6], posY[subLigt*MAX_PNTS*2 + sideIndex + 6], posZ[subLigt*MAX_PNTS*2 + sideIndex + 6]);

                        for(int k=0; k<2; k++)
                        {
                            float3 vP = k==0 ? vFaceMi : vFaceMa;
                            if(f==0 && k==0) { vMin=vP; vMax=vP; }

                            vMax = max(vMax, vP); vMin = min(vMin, vP);
                        }
                    }
                    bSetBoundYet=true;
                }
            }
            else        // :( need true clipping
            {

                for(f=0; f<6; f++)
                {
                    float3 q0, q1, q2, q3;
                    GetHullQuad(q0, q1, q2, q3, boxX, boxY, boxZ, center, scaleXY, f);

                    // 4 vertices to a quad of the convex hull in post projection space
                    const float4 vP0 = mul(g_mProjection, float4(q0, 1));
                    const float4 vP1 = mul(g_mProjection, float4(q1, 1));
                    const float4 vP2 = mul(g_mProjection, float4(q2, 1));
                    const float4 vP3 = mul(g_mProjection, float4(q3, 1));


                    int iSrcIndex = 0;

                    int offs = iSrcIndex*MAX_PNTS+subLigt*MAX_PNTS*2;

                    // fill up source clip buffer with the quad
                    posX[offs+0]=vP0.x; posX[offs+1]=vP1.x; posX[offs+2]=vP2.x; posX[offs+3]=vP3.x;
                    posY[offs+0]=vP0.y; posY[offs+1]=vP1.y; posY[offs+2]=vP2.y; posY[offs+3]=vP3.y;
                    posZ[offs+0]=vP0.z; posZ[offs+1]=vP1.z; posZ[offs+2]=vP2.z; posZ[offs+3]=vP3.z;
                    posW[offs+0]=vP0.w; posW[offs+1]=vP1.w; posW[offs+2]=vP2.w; posW[offs+3]=vP3.w;

                    int iNrSrcVerts = 4;

                    // do true clipping
                    for(int p=0; p<6; p++)
                    {
                        const int nrVertsDst = ClipAgainstPlane(iSrcIndex, iNrSrcVerts, subLigt, p);

                        iSrcIndex = 1-iSrcIndex;
                        iNrSrcVerts = nrVertsDst;

                        if(iNrSrcVerts<3 || iNrSrcVerts>=MAX_PNTS) break;
                    }

                    // final clipped convex primitive is in src buffer
                    if(iNrSrcVerts>2)
                    {
                        int offs_src = iSrcIndex*MAX_PNTS+subLigt*MAX_PNTS*2;
                        for(int k=0; k<iNrSrcVerts; k++)
                        {
                            float4 vCur = float4(posX[offs_src+k], posY[offs_src+k], posZ[offs_src+k], posW[offs_src+k]);

                            // project and apply toward AABB
                            float3 vP = float3(vCur.x/vCur.w, vCur.y/vCur.w, vCur.z/vCur.w);
                            if(!bSetBoundYet) { vMin=vP; vMax=vP; bSetBoundYet=true; }

                            vMax = max(vMax, vP); vMin = min(vMin, vP);
                        }
                    }

                }

                ////////////////////// look for camera frustum verts that need to be included. That is frustum vertices inside the convex hull for the light
#ifdef USE_OBLIQUE_MODE
				bool bIsObliqueClipPlane = true;
#else
				bool bIsObliqueClipPlane = false;
#endif
				const int nrFrustVertsToTest = bIsObliqueClipPlane ? 4 : 8;

                int i=0;
                for(i=0; i<nrFrustVertsToTest; i++)  // establish 8 camera frustum vertices
                {
                    float3 vVertPSpace = float3((i&1)!=0 ? 1 : (-1), (i&2)!=0 ? 1 : (-1), (i&4)!=0 ? 1 : 0);

                    float4 v4ViewSpace = mul(g_mInvProjection, float4(vVertPSpace,1));
                    float3 vViewSpace = float3(v4ViewSpace.x/v4ViewSpace.w, v4ViewSpace.y/v4ViewSpace.w, v4ViewSpace.z/v4ViewSpace.w);

                    posX[subLigt*MAX_PNTS*2 + i] = vViewSpace.x;
                    posY[subLigt*MAX_PNTS*2 + i] = vViewSpace.y;
                    posZ[subLigt*MAX_PNTS*2 + i] = vViewSpace.z;
                }

                // determine which camera frustum vertices are inside the convex hull
                uint uVisibFl = 0xff;
                for(f=0; f<6; f++)
                {
                    float3 vP0, vN;
                    GetHullPlane(vP0, vN, boxX, boxY, boxZ, center, scaleXY, f);

                    for(i=0; i<nrFrustVertsToTest; i++)
                    {
                        float3 vViewSpace = float3(posX[subLigt*MAX_PNTS*2 + i], posY[subLigt*MAX_PNTS*2 + i], posZ[subLigt*MAX_PNTS*2 + i]);
                        uVisibFl &= ( dot(vViewSpace-vP0, vN)<0 ? 0xff : (~(1<<i)) );
                    }
                }

                // apply camera frustum vertices inside the convex hull to the AABB
                for(i=0; i<nrFrustVertsToTest; i++)
                {
                    if((uVisibFl&(1<<i))!=0)
                    {
                        float3 vP = float3((i&1)!=0 ? 1 : (-1), (i&2)!=0 ? 1 : (-1), (i&4)!=0 ? 1 : 0);

                        if(!bSetBoundYet) { vMin=vP; vMax=vP; bSetBoundYet=true; }

                        vMax = max(vMax, vP); vMin = min(vMin, vP);
                    }
                }
            }





            // determine AABB bound in [-1;1]x[-1;1] screen space using bounding sphere.
            // Use the result to make our already established AABB from the convex hull
            // potentially tighter.
            if(!bSetBoundYet)
            {
                // set the AABB off-screen
                vMin = float3(-3,-3,-3);
                vMax = float3(-2,-2,-2);
            }
            else
            {
                //if((center.z+radius)<0.0)
                if(g_isOrthographic==0 && length(center)>radius)
                {
                    float2 vMi, vMa;
                    bool2 bMi, bMa;
                    CalcBound(bMi, bMa, vMi, vMa, g_mInvProjection, center, radius);

                    vMin.xy = bMi ? max(vMin.xy, vMi) : vMin.xy;
                    vMax.xy = bMa ? min(vMax.xy, vMa) : vMax.xy;
                }
                else if(g_isOrthographic!=0)
                {
                    float2 vMi = mul(g_mProjection, float4(center.xyz-radius,1)).xy;     // no division needed for ortho
                    float2 vMa = mul(g_mProjection, float4(center.xyz+radius,1)).xy;     // no division needed for ortho
                    vMin.xy = max(vMin.xy, vMi);
                    vMax.xy = min(vMax.xy, vMa);
                }
#ifndef USE_OBLIQUE_MODE
#if USE_LEFT_HAND_CAMERA_SPACE
                if((center.z-radius)>0.0)
                {
                    float4 vPosF = mul(g_mProjection, float4(0,0,center.z-radius,1));
                    vMin.z = max(vMin.z, vPosF.z/vPosF.w);
                }
                if((center.z+radius)>0.0)
                {
                    float4 vPosB = mul(g_mProjection, float4(0,0,center.z+radius,1));
                    vMax.z = min(vMax.z, vPosB.z/vPosB.w);
                }
#else
                if((center.z+radius)<0.0)
                {
                    float4 vPosF = mul(g_mProjection, float4(0,0,center.z+radius,1));
                    vMin.z = max(vMin.z, vPosF.z/vPosF.w);
                }
                if((center.z-radius)<0.0)
                {
                    float4 vPosB = mul(g_mProjection, float4(0,0,center.z-radius,1));
                    vMax.z = min(vMax.z, vPosB.z/vPosB.w);
                }
#endif
                else
                {
                    vMin = float3(-3,-3,-3);
                    vMax = float3(-2,-2,-2);
                }
#endif
            }


            // we should consider doing a look-up here into a max depth mip chain
            // to see if the light is occluded: vMin.z*VIEWPORT_SCALE_Z > MipTexelMaxDepth
            //g_vBoundsBuffer[lgtIndex+0] = float3(0.5*vMin.x+0.5, -0.5*vMax.y+0.5, vMin.z*VIEWPORT_SCALE_Z);
            //g_vBoundsBuffer[lgtIndex+g_iNrVisibLights] = float3(0.5*vMax.x+0.5, -0.5*vMin.y+0.5, vMax.z*VIEWPORT_SCALE_Z);

            // changed for unity

            // Each light's AABB is represented by two float3s, the min and max of the box.
            // And for stereo, we have two sets of lights.  Therefore, each eye has a set of mins, followed by
            // a set of maxs, and each set is equal to g_iNrVisibLights.
            const ScreenSpaceBoundsIndices boundsIndices = GenerateScreenSpaceBoundsIndices(lgtIndex, g_iNrVisibLights, eyeIndex);

			// build a linear (in camera space) min/max Z for the aabb. This is needed for clustered when oblique is active
			float linMiZ, linMaZ;
#ifndef USE_OBLIQUE_MODE
			float2 vMiZW = mul(g_mInvProjection, float4(vMin,1)).zw;
			float2 vMaZW = mul(g_mInvProjection, float4(vMax,1)).zw;
			linMiZ = vMiZW.x/vMiZW.y; linMaZ = vMaZW.x/vMaZW.y;
#else
			for(int i=0; i<8; i++)  // establish 8 aabb points in camera space.
            {
                float3 vP = float3((i&1)!=0 ? vMax.x : vMin.x, (i&2)!=0 ? vMax.y : vMin.y, (i&4)!=0 ? vMax.z : vMin.z);

                float2 v2Pc = mul(g_mInvProjection, float4(vP,1)).zw;
                float linZ = v2Pc.x/v2Pc.y;

				if(i==0) { linMiZ=linZ; linMaZ=linZ; }
#if USE_LEFT_HAND_CAMERA_SPACE
				linMiZ = min(linMiZ, linZ); linMaZ = max(linMaZ, linZ);
#else
				linMiZ = max(linMiZ, linZ); linMaZ = min(linMaZ, linZ);
#endif
            }

			float z0 = center.z-radius, z1 = center.z+radius;
#if USE_LEFT_HAND_CAMERA_SPACE
			linMiZ = max(linMiZ, z0); linMaZ = min(linMaZ, z1);
#else
			linMiZ = min(linMiZ, z1); linMaZ = max(linMaZ, z0);
#endif

#endif

            g_vBoundsBuffer[boundsIndices.min] = float4(0.5*vMin.x + 0.5, 0.5*vMin.y + 0.5, vMin.z*VIEWPORT_SCALE_Z, linMiZ);
            g_vBoundsBuffer[boundsIndices.max] = float4(0.5*vMax.x + 0.5, 0.5*vMax.y + 0.5, vMax.z*VIEWPORT_SCALE_Z, linMaZ);
        }
    }
#endif // Z_BINNING
}

#ifndef Z_BINNING

float4 GenNewVert(const float4 vVisib, const float4 vInvisib, const int p);

int ClipAgainstPlane(const int iSrcIndex, const int iNrSrcVerts, const int subLigt, const int p)
{
    int offs_src = iSrcIndex*MAX_PNTS+subLigt*MAX_PNTS*2;
    int offs_dst = (1-iSrcIndex)*MAX_PNTS+subLigt*MAX_PNTS*2;

    float4 vPrev = float4(posX[offs_src+(iNrSrcVerts-1)], posY[offs_src+(iNrSrcVerts-1)], posZ[offs_src+(iNrSrcVerts-1)], posW[offs_src+(iNrSrcVerts-1)]);

    int nrVertsDst = 0;

    unsigned int uMask = (1<<p);
    bool bIsPrevVisib = (GetClip(vPrev)&uMask)==0;
    for(int i=0; i<iNrSrcVerts; i++)
    {
        float4 vCur = float4(posX[offs_src+i], posY[offs_src+i], posZ[offs_src+i], posW[offs_src+i]);
        bool bIsCurVisib = (GetClip(vCur)&uMask)==0;
        if( (bIsCurVisib && !bIsPrevVisib) || (!bIsCurVisib && bIsPrevVisib) )
        {
            //assert(nrVertsDst<MAX_PNTS);
            if(nrVertsDst<MAX_PNTS)
            {
                // generate new vertex
                float4 vNew = GenNewVert(bIsCurVisib ? vCur : vPrev, bIsCurVisib ? vPrev : vCur, p);
                posX[offs_dst+nrVertsDst]=vNew.x; posY[offs_dst+nrVertsDst]=vNew.y; posZ[offs_dst+nrVertsDst]=vNew.z; posW[offs_dst+nrVertsDst]=vNew.w;
                ++nrVertsDst;
            }
        }

        if(bIsCurVisib)
        {
            //assert(nrVertsDst<MAX_PNTS);
            if(nrVertsDst<MAX_PNTS)
            {
                posX[offs_dst+nrVertsDst]=vCur.x; posY[offs_dst+nrVertsDst]=vCur.y; posZ[offs_dst+nrVertsDst]=vCur.z; posW[offs_dst+nrVertsDst]=vCur.w;
                ++nrVertsDst;
            }
        }

        vPrev = vCur;
        bIsPrevVisib = bIsCurVisib;
    }

    return nrVertsDst;
}



unsigned int GetClip(const float4 P)
{
#ifdef USE_OBLIQUE_MODE
	bool bIsObliqueClipPlane = true;
#else
	bool bIsObliqueClipPlane = false;
#endif

    //-P.w <= P.x <= P.w
    return (((P.x<-P.w)?1:0) | ((P.x>P.w)?2:0) | ((P.y<-P.w)?4:0) | ((P.y>P.w)?8:0) | ((P.z<0)?16:0) | ((P.z>P.w)?32:0)) & (bIsObliqueClipPlane ? 0x1f : 0x3f);
}

float4 GenNewVert(const float4 vVisib, const float4 vInvisib, const int p)
{
    const float fS = p==4 ? 0 : ((p&1)==0 ? -1 : 1);
    const int index = ((uint) p)/2;
    float x1 = index==0 ? vVisib.x : (index==1 ? vVisib.y : vVisib.z);
    float x0 = index==0 ? vInvisib.x : (index==1 ? vInvisib.y : vInvisib.z);

    //fS*((vVisib.w-vInvisib.w)*t + vInvisib.w) = (x1-x0)*t + x0;

    const float fT = (fS*vInvisib.w-x0)/((x1-x0) - fS*(vVisib.w-vInvisib.w));
    float4 vNew = vVisib*fT + vInvisib*(1-fT);

    // just to be really anal we make sure the clipped against coordinate is precise
    if(index==0) vNew.x = fS*vNew.w;
    else if(index==1) vNew.y = fS*vNew.w;
    else vNew.z = fS*vNew.w;

    return vNew;
}


float4 TransformPlaneToPostSpace(float4x4 InvProjection, float4 plane)
{
    return mul(plane, InvProjection);
}

float4 EvalPlanePair(out bool validPlanes, float2 posXY_in, float r)
{
    // rotate by 90 degrees to avoid potential division by zero
    bool bMustFlip = abs(posXY_in.y)<abs(posXY_in.x);
    float2 posXY = bMustFlip ? float2(-posXY_in.y, posXY_in.x) : posXY_in;

    float fLenSQ = dot(posXY, posXY);
    float diffSq = fLenSQ - r*r;
    float D = posXY.y * sqrt(max(0.0, diffSq));

    float4 res;
    res.x = (-r*posXY.x - D) / fLenSQ;
    res.z = (-r*posXY.x + D) / fLenSQ;
    res.y = (-r-res.x*posXY.x) / posXY.y;
    res.w = (-r-res.z*posXY.x) / posXY.y;

    // rotate back by 90 degrees
    res = bMustFlip ? float4(res.y, -res.x, res.w, -res.z) : res;

    validPlanes = diffSq>0.0;

    return res;
}

void CalcBound(out bool2 bIsMinValid, out bool2 bIsMaxValid, out float2 vMin, out float2 vMax, float4x4 InvProjection, float3 pos_view_space, float r)
{
    bool validX, validY;
    float4 planeX = EvalPlanePair(validX, float2(pos_view_space.x, pos_view_space.z), r);
    float4 planeY = EvalPlanePair(validY, float2(pos_view_space.y, pos_view_space.z), r);


#if USE_LEFT_HAND_CAMERA_SPACE
    planeX = planeX.zwxy;       // need to swap left/right and top/bottom planes when using left hand system
    planeY = planeY.zwxy;
#endif

    bIsMinValid = bool2(planeX.z<0, planeY.z<0) && bool2(validX,validY);
    bIsMaxValid = bool2((-planeX.x)<0, (-planeY.x)<0) && bool2(validX,validY);

    // hopefully the compiler takes zeros into account
    // should be the case since the transformation in TransformPlaneToPostSpace()
    // is done using multiply-adds and not dot product instructions.
    float4 planeX0 = TransformPlaneToPostSpace(InvProjection, float4(planeX.x, 0, planeX.y, 0));
    float4 planeX1 = TransformPlaneToPostSpace(InvProjection, float4(planeX.z, 0, planeX.w, 0));
    float4 planeY0 = TransformPlaneToPostSpace(InvProjection, float4(0, planeY.x, planeY.y, 0));
    float4 planeY1 = TransformPlaneToPostSpace(InvProjection, float4(0, planeY.z, planeY.w, 0));


    // convert planes to the forms (1,0,0,D) and (0,1,0,D)
    // 2D bound is given by -D components
    float2 A = -float2(planeX0.w / planeX0.x, planeY0.w / planeY0.y);
    float2 B = -float2(planeX1.w / planeX1.x, planeY1.w / planeY1.y);

    // Bound is complete
    vMin = B;
    vMax = A;
}

#endif // !Z_BINNING